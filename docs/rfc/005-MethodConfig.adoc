= RFC Template

*Name:* Method Config

*Type:* feature

*Author:* https://github.com/KirillPamPam

== Summary

Weâ€™d like to have a flexible config with all chain methods where it's possible to customize them in some way and add additional settings that might be useful for further processing.

It will be public method specifications.

== Detailed design

There is an example of the method config:

[source,yaml]
----
spec:
  name: EVM
  spec-imports:
    - ANOTHER_SPEC_NAME
  api:
    - group: some_group_to_disable # an existed group from the imported spec
      enabled: false # true/false, true by default
    - group: default # trace, debug, any group that combines methods
      interface: json-rpc # rest, grpc
      type: POST # GET, etc
      methods:
        - name: method_name
          enabled: false # true/false, true by default
          settings:
            cacheable: false # true/false, true by default
            subscription:
              name: eth_subscription # can be used to build a ws event
              type: WS # server-side-events
              unsub-method: unsub_method
          tag-parsers:
            - parser: PARSER_NAME
              args:
                - "block"
                - "1"
            - parser: ANOTHER_PARSER_NAME
              args:
                - "hash"
                - "1"
                - "block_hash"
----

The main ideas are:

* to have a separate yaml file for a chain with methods and their settings (in other words it's a specification of chain methods)
* to import such specification - it means that methods from one specification can be added to another one
* to have as many methods settings as possible, like:
** method name
** method interface
** what method group it belongs to
** if it's cacheable or not
** if it's disable for a specific chain
** if it's a subscription method
** method parsers to extract some params
** etc
* to add such specification to the https://github.com/drpcorg/public/blob/main/chains.yaml file and have all chain settings in one place but not in code

Now it's necessary to look at each component in detail

=== "spec"

[source,yaml]
----
spec:
  name: EVM
  spec-imports:
    - ANOTHER_SPEC_NAME
  api: # methods themselves
----

The `spec` section includes:

* `name` - a specification name; required and unique param
* `api` - an array of method groups with their settings and method settings; required param
* `spec-imports` - an array of other specs that are imported; optional param; default is an empty array

Import rules:

* all method groups with their settings and methods are imported, starting from the very first specification in the hierarchy
* it is possible so specify the same group method as in the parent specification with the following rules:
** it is possible to disable the whole method group setting `enabled` to *false*
** to override the method group settings, it's necessary to specify them explicitly, otherwise the parent method group setting are used
** to override the method settings, it's necessary to specify them explicitly, otherwise the parent method settings are used
** groups with the same name are merged following the above override rules

=== "api"

The `api` section is an array of method groups. Each method group includes:

* `group` - a method group name; required param
* `enabled` - a bool flag if a method group is enabled/disabled; optional param; default is *true*
* `interface` - a type of interface through which the methods of this group operate; required param; possible values:
** json-rpc
** grpc
** rest
* `type` - this applies only to http protocol methods - it's a type of HTTP method (GET, POST, etc.); optional param; default is empty
* `methods` - method settings; optional value; default is an empty array

=== "methods"

The `methods` section in the method group is an array of method configs. Each method includes:

* `name` - a method name; required param
* `enabled` - a bool flag if a method is enabled/disabled; optional param; default is *true*
* `settings` - additional method settings:
** `cacheable` - a bool flag if a method is cacheable; optional param; default is *true*
** `subscription` - additional settings for subscription methods:
*** `name` - a subscription name; required param
*** `type` - a subscription method type (WS, SSE, etc.); required param
*** `unsub-method` - a method name to unsubscribe; optional param; default is empty
* `tag-parsers` - configurations of parsers to extract  some values that may be useful for further processing; optional param; default is empty

==== "tag-parsers"

By default, the tag parser is a combination of two parameters - the type to be extracted and the path to it.

Example:

[source,yaml]
----
parsers:
  - type: blockTag
    path: "0"
  - type: blockNumber
    path: "max([path], [path])"
  - type: blockNumber
    path: "0, block_number"
  - type: hash
    path: "0, values, 0, hash"
----

===== "path"

`path` is an abstract value in which the specified `type` should be found and extracted. The exact `path` value depends on the method interface:

* for *json-rpc* it is the json path to the value in the "params" field; "params" can be either an array or an object:
** this path can use indexes and field names separated by commas
** in some json-rpc methods it's necessary to apply a special function to choose between a few value (for example, the maximum value between `toBlock` and `fromBlock` in eth_getLogs should be extracted); that's why it's possible to specify such functions in the `path` - args of these functions are json paths with the same rules; possible values:
*** `max([path], [path])` - a function to get the maximum value between 2 args
* for *rest* it is the path to the path or query param in the url

===== "type"

`type` is a value type to be extracted. It's necessary to understand it in advance to deserialize this value correctly.

Possible value:

* `blockTag` - a block number (or tag) or a hash string
** json-rpc specific
** some json rpc methods can work with the both params - numbers and hashes, so it's necessary to distinguish between them
* `blockNumber` - a block number (or tag)
** json-rpc specific
** in json-rpc numbers are hex or tags (latest, pending, etc)
* `hash` - a hash as a string
* `number` - a decimal number

There will be default parser implementations for each interface, and for most cases that's enough. However, there might be very tricky logic behind extracting the value so that it's impossible to describe it by a simple path. For such cases it's necessary to specify custom parsers, and they will be used to extract the value instead of a default one.

Example:

[source,yaml]
----
parsers:
  - name: MyCustomParser
----

== Unresolved questions
